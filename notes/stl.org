* Item 4 Call empty instead of checking size() against zero
  You should prefer the construct using ~empty~, and the reason is simple: empty is a constant-time operation for all standard containers, but for some list implementation, ~size~ takes linear time.
  #+BEGIN_SRC c++
    list<int> list1;
    list<int> list2;

    list1.splice(
      list1.end(), list2,
      find(list2.begin(), list2.end(), 5),
      find(list2.rbegin(), list2.rend(), 10).base()
      );
  #+END_SRC
  without traversing the range and couting ~list2~, there is no way to know how many items will be in ~list1~
* Item 5 Prefer range member functions to their single-element counterparts
  #+BEGIN_SRC c++
    v1.assign(v2.begin() + v2.size() / 2, v2.end());
  #+END_SRC
  /range member functions/ are superior to their single-element alternatives.
  The loop also happens to impose an efficiency penalty.

  poor code
  #+BEGIN_SRC c++
    vector<Widget> v1, v2;
    v1.clear();
    for (vector<Widget>::const_iterator ci = v2.begin() + v2.size() / 2; ci != v2.end(); ++ ci) {
      v1.push_back(*ci);
    }
  #+END_SRC

  There is no more loop presented in the code, one certainly exists inside copy.
  As a result, the efficiency *penalty* remains. (poor code)
  #+BEGIN_SRC c++
    copy(v2.begin() + v2.size()/2, v2.end(), back_inserter(v1));
  #+END_SRC


  Using /range functions/ such as ~assign~ and ~insert~ instead of ~back_inserter~, ~front_inserter~, ~inserter~
  #+BEGIN_SRC c++
  v1.insert(v1.end(), v2.begin() + v2.size()/2, v2.end());
  #+END_SRC

  - It's generally less work to write the code using the range member functions
  - Range member functions tend to lead to code that is clearer and more straightforward.

    #+BEGIN_SRC c++
      int data[numValues];

      vector<int> v1;
      v1.insert(v1.begin(), data, data+numValues);
    #+END_SRC

    poor code
    #+BEGIN_SRC c++
      vector<int>::iterator insertLoc(v.begin());
      for (int i = 0; i < numValues; i++) {
        insertLoc = v.insert(insertLoc, data[i]);
      }
    #+END_SRC

    poor code
    #+BEGIN_SRC c++
      copy(data, data + numValues, inserter(v, v.begin()));
    #+END_SRC
    the code based on copy and the code using the explicit loop will be almost identical.

    the code using the single-element version of insert levies up to three different performance taxes on you, none of which you pay if you use the range version of insert.
    - The first tax consists of unnecessary function calls.
      + call ~insert~ function ~numValues~ times, whereas using range functions, only one function call
    - The cost of inefficiently moving the existing elements in v to their final post-insertion positions
    - Has to do with memory allocation, though it has a nasty copying side to it. the vector allocates new memory with more capacity,
      copies its elements from the old memory to the new memory, destroys the elements in the old memory, and deallocates the old memory.
      Then it adds the element that is being inserted.

  The only standard iterators that don't offer forward iterator capabilities are input iterators and output iterators. In that only case, range insert must move elements
  into their final positions one place at a time, too.

  - Range contruction: all standard containers offer a constructor of this form:
    #+BEGIN_SRC c++
      container::container(InputIterator begin, InputIterator end);
    #+END_SRC
    be aware of ~istream_iterators~ and ~istreambuf_iterators~
  - Range insertion
    #+BEGIN_SRC c++
    void container::insertr(iteration pos, InputIterator begin, InputIterator end);
    #+END_SRC
  - Range erasure
    #+BEGIN_SRC c++
      void container::erase(InputIterator begin, InputIterator end); // associative container
      iterator container::erase(InputIterator begin, InputIterator end); // sequence container
    #+END_SRC
  - Range assignment
    #+BEGIN_SRC c++
    void container::assign(iterator pos, InputIterator begin, InputIterator end);
    #+END_SRC
* Item 6 Be alert for C++'s most vexing parse
  #+BEGIN_SRC c++
    ifstream dataFile("ints.dat");
    list<int> data(istream_iterator<int>(dataFile), istream_iterator<int>());
  #+END_SRC
  The idea here is to pass a pair of istream_iterators to list's range constructor, thus coping the ints in thefile into the list.
  compile successfully, but at runtime, do nothing.
  #+BEGIN_SRC c++
    int f(double d);                //
    int f(double (d));              // same as above; parens around ~d~ are ignored
    int f(double);                  // same as above; parameter name is omitted
  #+END_SRC
  function pointer
  #+BEGIN_SRC c++
    int g(double (*pf)());          // ~g~ takes a pointer to a function as paramter
    int g(double pf());             // same as above; pf is implicitly a pointer
    int g(double ())                // same as above; parametr name is omitted
  #+END_SRC

  Notice the difference between parentheses aroud /a parameter name/ (such as ~d~ in the second declaration for ~f~) and /standing by themselves/.
  Parentheses around a parameter name are ignored, but parentheses sstanding by themselves indicate the existence of a parameter list: they announce the
  presence of a parameter that is itself a pointer to a function.

  #+BEGIN_SRC c++
  list<int> data(istream_iterator<int>(dataFile), istream_iterator<int>());
  #+END_SRC
  This declares a /function/, ~data~, whose return type is ~list<int>~. The function data takes two parameters:
  - the first parameter is named ~dataFile~. the paraentheses around dataFile are superfluous and are ignored
  - The second parameter has no name. Its type is pointer to function taking nothing and returning an istream_iterator<int>


  #+BEGIN_SRC c++
    class Widget {};
    Widget w();
  #+END_SRC
  This doesn't declare a ~Widget~ named ~w~, it declares a function named ~w~ that takes nothing and returns a ~Widget~

  #+BEGIN_SRC c++
    list<int> data( (istream_iterator<int>(dataFile)), istream_iterator<int>());
  #+END_SRC
  This is the proper way to declare data, and given the utility of istream_iterators and range constructors.

  #+BEGIN_SRC c++
    ifstream dataFile("ints.dat");
    istream_iterator<int> dataBegin(dataFile);
    istream_iterator<int> dataEnd;
    list<int> data(dataBegin, dataEnd);
  #+END_SRC
  work everywhere.
* Item 29
